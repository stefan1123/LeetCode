"""
题目描述
    在一根无限长的数轴上，你站在0的位置。终点在target的位置。    
    每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。    
    返回到达终点需要的最小移动次数。
代码情况：accepted
"""

"""
解题思路：
    1. target是正是负，解法一样
    2. 向右走是加，向左走是减，那我们可以先不停的向右走，那么走的格数就是1+2+3+… 当无法得到给定
    的target值时，代表我们其中是有几步是需要向左走的；那么向左走一步，会导致结果减小2对应的步数。
    比如第二格我们向左，本来是加2，现在是减2，一来一去少了2*2=4格。向左走也就是在连加的起初上减去
    某个数反向的情况（即2的倍数）。
    3. 1+2+3+...+n 求和公式为 n(n+1)/2, 即求 n(n+1)/2 = target 成立时n 的值；
    4. 根据求根公式，求出一元二次方程的解，即 n = sqrt(1+8*a)/2 - 0.5
    5. 当n为整数时，说明在第n次向右走n步之后就找到了target；
    6. 当n不为整数时，去找一个数，使得前n步之后加上该数，和大于target,这个数为 n+1
    7. 求出 1+2+...+n+(n+1) 的和超出target的部分，若超出部分为偶数，则返回当前的n+1，因为
    把前面的某个数反向就可以把超出部分抵消
    8. 如果超出部分为奇数，则加上一个奇数，使得超出部分为偶数（即当前的n=n+1为奇数，则加上的数为n+2(下一个奇数);
    若为偶数时，加上n+1）
"""

class Solution(object):
    def reachNumber(self, target):
        """
        :type target: int
        :rtype: int
        """
        if target < 0:
            target = 0 - target
        # 找出从1+2+3+...+x = target时的解
        x = (pow(1+8*target,0.5)/2) - 0.5
        # x = math.sqrt(1/4+2*target)-0.5
        if x == int(x):
            # print(int(x))
            return int(x)
        else:
            # 寻找一个最后一个数，使得加上这个数，和大于target
            x = int(x)+1
            # 求从1+2+...+x+（x+1）的和超出target的部分
            delta = (x**2 + x - 2*target )/2
            # 如果超出的部分是奇数，则需要在加上一个奇数，使超出的部分变成偶数，此时把前面的某个数反向即可
            # 如果超出的部分是偶数，则返回该数即可，因为把前面的某个数反向就可以把超出部分抵消
            if delta % 2 != 0:
                if x % 2 != 0:
                    return x+2
                return x+1
            return x
        
if __name__ == "__main__":
    s = Solution()
    tar = 13
    res = s.reachNumber(tar)
